import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeSet;

public class AllInOne {

    // Задача 45: Арабские -> Римские
    private static final int[] VALUES = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    private static final String[] SYMBOLS = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

    public static String arabicToRoman(int num) {
        // Проверка диапазона: если число вне 1 < n < 10000 — исключение
        if (num <= 0 || num >= 10000) {
            throw new IllegalArgumentException("Допустимый диапазон: 1 < n < 10000");
        }
        StringBuilder roman = new StringBuilder();
        int remaining = num;
        for (int i = 0; i < VALUES.length; i++) {
            while (remaining >= VALUES[i]) {
                roman.append(SYMBOLS[i]);
                remaining -= VALUES[i];
            }
        }
        return roman.toString();
    }

    // Задача 46: Римские -> Арабские
    private static final Map<Character, Integer> ROMAN_VALUES = new HashMap<>();
    static {
        ROMAN_VALUES.put('I', 1);
        ROMAN_VALUES.put('V', 5);
        ROMAN_VALUES.put('X', 10);
        ROMAN_VALUES.put('L', 50);
        ROMAN_VALUES.put('C', 100);
        ROMAN_VALUES.put('D', 500);
        ROMAN_VALUES.put('M', 1000);
    }

    public static int romanToArabic(String roman) {
        if (roman == null || roman.isEmpty()) {
            throw new IllegalArgumentException("Строка не может быть пустой");
        }
        int total = 0;
        int prevValue = 0;
        for (int i = roman.length() - 1; i >= 0; i--) {
            char c = roman.charAt(i);
            int value = ROMAN_VALUES.getOrDefault(c, 0);
            if (value < prevValue) {
                total -= value;
            } else {
                total += value;
            }
            prevValue = value;
        }
        if (total <= 1 || total >= 10000) {
            throw new IllegalArgumentException("Результат вне диапазона 1 < n < 10000");
        }
        return total;
    }

    //Задача 47: Сортировка змейкой
    public static int[] snailSort(int[][] array) {
        if (array == null || array.length == 0 || array[0].length == 0) {
            return new int[0];
        }
        int n = array.length;
        int[] result = new int[n * n];
        int index = 0;
        int rowStart = 0, rowEnd = n - 1;
        int colStart = 0, colEnd = n - 1;

        while (rowStart <= rowEnd && colStart <= colEnd) {
            for (int i = colStart; i <= colEnd; i++) {
                result[index++] = array[rowStart][i];
            }
            rowStart++;

            for (int i = rowStart; i <= rowEnd; i++) {
                result[index++] = array[i][colEnd];
            }
            colEnd--;

            if (rowStart <= rowEnd) {
                for (int i = colEnd; i >= colStart; i--) {
                    result[index++] = array[rowEnd][i];
                }
                rowEnd--;
            }

            if (colStart <= colEnd) {
                for (int i = rowEnd; i >= rowStart; i--) {
                    result[index++] = array[i][colStart];
                }
                colStart++;
            }
        }
        return result;
    }

    //Задача 48: Последовательность u
    public static int[] generateUSequence(int x) {
        if (x < 0) {
            throw new IllegalArgumentException("x не может быть отрицательным");
        }
        // TreeSet использовано для автоматической сортировки и избегания дубликатов
        TreeSet<Integer> sequence = new TreeSet<>();
        sequence.add(1);

        for (int i = 0; i < x; i++) {
            int current = sequence.first();
            sequence.remove(current);
            sequence.add(2 * current + 1);
            sequence.add(3 * current + 1);
        }

        int[] result = new int[Math.min(x + 1, sequence.size())];
        int index = 0;
        for (int num : sequence) {
            if (index >= result.length) break;
            result[index++] = num;
        }
        return result;
    }

    // Задача 49: Функция fusc
    public static int fusc(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        if (n % 2 == 0) {
            return fusc(n / 2);
        } else {
            int k = (n - 1) / 2;
            return fusc(k) + fusc(k + 1);
        }
    }

    public static void main(String[] args) {
        // Примеры вызовов:
        System.out.println("45. Арабские -> Римские:");
        System.out.println("1984 -> " + arabicToRoman(1984)); // MCMLXXXIV

        System.out.println("\n46. Римские -> Арабские:");
        System.out.println("MCMLXXXIV -> " + romanToArabic("MCMLXXXIV")); // 1984

        System.out.println("\n47. Сортировка змейкой:");
        int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        System.out.println(Arrays.toString(snailSort(matrix))); // [1, 2, 3, 6, 9, 8, 7, 4, 5]

        System.out.println("\n48. Последовательность u:");
        System.out.println(Arrays.toString(generateUSequence(10))); // [1, 3, 4, 7, 9, 10, ...]

        System.out.println("\n49. Функция fusc:");
        for (int i = 0; i < 10; i++) {
            System.out.print(fusc(i) + " "); // 0 1 1 2 1 3 2 3 1 4
        }
    }
}